Binding a Client to a Server
To allow a client to call a server, it is necessary that the server be registered
and prepared to accept incoming calls. Registration of a server makes it possible
for a client to locate the server and bind to it. Server location is done in two steps:
1. Locate the server's machine.
2. Locate the server (i.e., the correct process) on that machine.
The second step is somewhat subtle. Basically, what it comes down to is that to
communicate with a server, the client needs to know an end point, on the server's
machine to which it can send messages. An end point (also commonly known as a
port) is used by the server's operating system to distinguish incoming messages
for different processes. In DCE, a table of (server, end point)pairs is maintained
on each server machine by a process called the DCE daemon. Before it becomes
available for incoming requests, the server must ask the operating system for an
end point. It then registers this end point with the DCE daemon. The DCE daemon
records this information (including which protocols the server speaks) in the end
point table for future use.
The server also registers with the directory service by providing it the network
address of the server's machine and a name under which the server can be looked
up. Binding a client to a server then proceeds as shown in Fig. 4-13.
Let us assume that the client wants to bind to a video server that is locally
known under the name /local/multimedia/video/movies .. It passes this name to the
directory server, which returns the network address of the machine running the
video server. The client then goes to the DCE daemon on that machine (which has
a well-known end point), and asks it to look up the end point of the video server in
its end point table. Armed with this information, the RPC can now take place. On
subsequent RPCs this lookup is not needed. DCE also gives clients the ability to
do more sophisticated searches for a suitable server when that is needed. Secure
RPC is also an option where confidentiality or data integrity is crucial.
140 COMMUNICA nON CHAP. 4
Performing an RPC
The actual RPC is carried out transparently and in the usual way. The client
stub marshals the parameters to the runtime library for transmission using the protocol
chosen at binding time. When a message arrives at the server side, it is
routed to the correct server based on the end point contained in the incoming message.
The runtime library passes the message to the server stub, which unmarshals
the parameters and calls the server. The reply goes back by the reverse route.
DCE provides several semantic options. The default is at-most-once operation,
in which case no call is ever carried out more than once, even in the face of
system crashes. In practice, what this means is that if a server crashes during, an
RPC and then recovers quickly, the client does not repeat the operation, for fear
that it might already have been carried out once.
Alternatively, it is possible to mark a remote procedure as idempotent (in the
IDL file), in which case it can be repeated multiple times without harm. For example,
reading a specified block from a file can be tried over and over until it
succeeds. When an idempotent RPC fails due to a server crash. the client can wait
until the server reboots and then try again. Other semantics are also available (but
rarely used), including broadcasting the RPC to all the machines on the local network.
We return to RPC semantics in Chap. 8, when discussing RPC in the presence
of failures.
4.3 MESSAGE-ORIENTED COMMUNICATION
Remote procedure calls and remote object invocations contribute to hiding
communication in distributed systems, that is, they enhance access transparency.
Unfortunately, neither mechanism is always appropriate. In particular, when it
cannot be assumed that the receiving side is executing at the time a request is
Figure 4-13. Client-to-server binding in DCE.
SEC. 4.3 MESSAGE-ORIENTED COMMUNICATION 141
issued, alternative communication services are needed. Likewise, the inherent
synchronous nature of RPCs, by which a client is blocked until its request has
been processed, sometimes needs to be replaced by something else.
That something else is messaging. In this section we concentrate on messageoriented
communication in distributed systems by first taking a closer look at
what exactly synchronous behavior is and what its implications are. Then, we discuss
messaging systems that assume that parties are executing at the time of communication.
Finally, we will examine message-queuing systems that allow processes
to exchange information, even if the other party is not executing at the time
communication is initiated.
4.3.1 Message-Oriented Transient Communication
Many distributed systems and applications are built directly on top of the simple
message-oriented model offered by the transport layer. To better understand
and appreciate the message-oriented systems as part of middleware solutions, we
first discuss messaging through transport-level sockets.
Berkeley Sockets
Special attention has been paid to standardizing the interface of the transport
layer to allow programmers to make use of its entire suite of (messaging) protocols
through a simple set of primitives. Also, standard interfaces make it easier to
port an application to a different machine.
As an example, we briefly discuss the sockets interface as introduced in the
1970s in Berkeley UNIX. Another important interface is XTI, which stands for
the X10pen Transport Interface, formerly called the Transport Layer Interface
(TLI), and developed by AT&T. Sockets and XTI are very similar in their model
of network programming, but differ in their set of primitives.
Conceptually, a socket is a communication end point to which an application
can write data that are to be sent out over the underlying network, and from which
incoming data can be read. A socket forms an abstraction over the actual communication
end point that is used by the local operating system for a specific transport
protocol. In the following text, we concentrate on the socket primitives for
TCP, which are shown in Fig. 4-14.
Servers generally execute the first four primitives, normally in the order
given. When calling the socket primitive, the caller creates a new communication
end point for a specific transport protocol. Internally, creating a communication
end point means that the local operating system reserves resources to accommodate
sending and receiving messages for the specified protocol.
The bind primitive associates a local address with the newly-created socket.
For example, a server